<!doctype html><html lang=en><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Liste - https://theden.github.io/thoughts.theden.sh/"><title>Kube Tricks | thoughts</title><meta name=description content><meta property="og:title" content="Kube Tricks"><meta property="og:description" content="Ephemeral Debug Containers # One can use ephemeral debug containers
Alternatively to edit in-place to test out configs and env vars use kubectl edit to modify a pod (or Deployment, StatefulSet etc.) YAML to update the command to do nothing so one can kubectl exec into the pod
apiVersion: v1 kind: Pod metadata: name: unstable-pod spec: containers: - name: unstable-pod image: foobar command: - sh - -c - &#34;tail -f /dev/null&#34; Ensure liveness and readiness probes are commented out if it depends on a runtime condition."><meta property="og:type" content="article"><meta property="og:url" content="https://theden.github.io/thoughts.theden.sh/posts/kube-tricks/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-11-10T00:00:00+00:00"><meta property="article:modified_time" content="2021-11-10T00:00:00+00:00"><meta itemprop=name content="Kube Tricks"><meta itemprop=description content="Ephemeral Debug Containers # One can use ephemeral debug containers
Alternatively to edit in-place to test out configs and env vars use kubectl edit to modify a pod (or Deployment, StatefulSet etc.) YAML to update the command to do nothing so one can kubectl exec into the pod
apiVersion: v1 kind: Pod metadata: name: unstable-pod spec: containers: - name: unstable-pod image: foobar command: - sh - -c - &#34;tail -f /dev/null&#34; Ensure liveness and readiness probes are commented out if it depends on a runtime condition."><meta itemprop=datePublished content="2021-11-10T00:00:00+00:00"><meta itemprop=dateModified content="2021-11-10T00:00:00+00:00"><meta itemprop=wordCount content="892"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="Kube Tricks"><meta name=twitter:description content="Ephemeral Debug Containers # One can use ephemeral debug containers
Alternatively to edit in-place to test out configs and env vars use kubectl edit to modify a pod (or Deployment, StatefulSet etc.) YAML to update the command to do nothing so one can kubectl exec into the pod
apiVersion: v1 kind: Pod metadata: name: unstable-pod spec: containers: - name: unstable-pod image: foobar command: - sh - -c - &#34;tail -f /dev/null&#34; Ensure liveness and readiness probes are commented out if it depends on a runtime condition."><link rel=canonical href=https://theden.github.io/thoughts.theden.sh/posts/kube-tricks/><meta name=monetization content="$twitter.xrptipbot.com/ronaldsvilcins"><link rel=dns-prefetch href=https://www.google-analytics.com><link href=https://www.google-analytics.com rel=preconnect crossorigin><link rel=alternate type=application/atom+xml title=thoughts href=https://theden.github.io/thoughts.theden.sh/atom.xml><link rel=alternate type=application/json title=thoughts href=https://theden.github.io/thoughts.theden.sh/feed.json><link rel="shortcut icon" type=image/png href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNk+A8AAQUBAScY42YAAAAASUVORK5CYII="><link href=https://theden.github.io/thoughts.theden.sh/css/custom.css rel=stylesheet><link rel=stylesheet href=https://theden.github.io/thoughts.theden.sh/css/hype.css id=hype><script>document.getElementById('hype').disabled=!0</script><script src=https://theden.github.io/thoughts.theden.sh/js/custom.js></script>
<link rel="shortcut icon" href=favicon.ico type=image/x-icon><style>*,:after,:before{box-sizing:border-box;padding:0}body{font:1rem/1.5 '-apple-system',BlinkMacSystemFont,avenir next,avenir,helvetica,helvetica neue,ubuntu,roboto,noto,segoe ui,arial,sans-serif;text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;padding:2rem;color:#096}.skip-link{position:absolute;top:-40px;left:0;background:#eee;z-index:100}.skip-link:focus{top:0}h1,h2,h3,h4,h5,strong,b{font-size:inherit;font-weight:600}header{line-height:2;padding-bottom:1.5rem}.link{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-decoration:none}.time{font-variant-numeric:tabular-nums;white-space:nowrap}blockquote{border-left:1px solid #096;padding-left:1rem;margin:0}a,a:visited{color:inherit}a:hover,a.heading-link{text-decoration:none}pre{padding:.5rem;overflow:auto;overflow-x:scroll;overflow-wrap:normal}code,pre{font-family:San Francisco Mono,Monaco,consolas,lucida console,dejavu sans mono,bitstream vera sans mono,monospace;font-size:normal;font-size:small}code{padding:0;border:none}ul{list-style-type:square}ul,ol{padding-left:1.2rem}.list{line-height:2;list-style-type:none;padding-left:0}.list li{padding-bottom:.1rem}.meta{color:#777}.content{max-width:70ch;margin:0 auto}header{line-height:2;display:flex;justify-content:space-between;padding-bottom:1rem}header a{text-decoration:none}header ul{list-style-type:none;padding:0}header li,header a{display:inline}h2.post{padding-top:.5rem}header ul a:first-child{padding-left:1rem}.nav{height:1px;background:#000;content:'';max-width:10%}.list li{display:flex;align-items:baseline}.list li time{flex:initial}.hr-list{margin-top:0;margin-bottom:0;margin-right:.5rem;margin-left:.5rem;height:1px;border:0;border-bottom:1px dotted #096;flex:1 0 1rem}.m,hr{border:0;margin:3rem 0}img{max-width:100%;height:auto}</style><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","articleSection":"posts","name":"Kube Tricks","headline":"Kube Tricks","alternativeHeadline":"","description":"Ephemeral Debug Containers # One can use ephemeral debug containers\nAlternatively to edit in-place to test out configs and env vars use kubectl edit to modify a pod (or Deployment, StatefulSet etc.) YAML to update the command to do nothing so one can kubectl exec into the pod\napiVersion: v1 kind: Pod metadata: name: unstable-pod spec: containers: - name: unstable-pod image: foobar command: - sh - -c - \u0026#34;tail -f \/dev\/null\u0026#34; Ensure liveness and readiness probes are commented out if it depends on a runtime condition.","inLanguage":"en-us","isFamilyFriendly":"true","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/theden.github.io\/thoughts.theden.sh\/posts\/kube-tricks\/"},"author":{"@type":"Person","name":""},"creator":{"@type":"Person","name":""},"accountablePerson":{"@type":"Person","name":""},"copyrightHolder":"thoughts","copyrightYear":"2021","dateCreated":"2021-11-10T00:00:00.00Z","datePublished":"2021-11-10T00:00:00.00Z","dateModified":"2021-11-10T00:00:00.00Z","publisher":{"@type":"Organization","name":"thoughts","url":"https://theden.github.io/thoughts.theden.sh/","logo":{"@type":"ImageObject","url":"https:\/\/theden.github.io\/thoughts.theden.sh\/","width":"32","height":"32"}},"image":"https://theden.github.io/thoughts.theden.sh/","url":"https:\/\/theden.github.io\/thoughts.theden.sh\/posts\/kube-tricks\/","wordCount":"892","genre":[],"keywords":[]}</script><a class=skip-link href=#main>Skip to main</a><main id=main><div class=content><header><p style=padding:0;margin:0><a href=/><b>thoughts.theden.sh</b></a><ul style=padding:0;margin:0><li><a href=https://theden.sh>About</a></ul></header><hr class=hr-list style=padding:0;margin:0><div style=float:right;padding-top:1em><button onclick=hype() class=button-hype role=button>HYPE</button></div><h2 class=post>Kube Tricks</h2><h2 id=ephemeral-debug-containers>Ephemeral Debug Containers <a href=#ephemeral-debug-containers class="hash g">#</a></h2><p>One can use <a href=https://kubernetes.io/docs/tasks/debug-application-cluster/debug-running-pod/#ephemeral-container>ephemeral debug containers</a><p>Alternatively to edit in-place to test out configs and env vars use <code>kubectl edit</code> to modify a pod (or <code>Deployment</code>, <code>StatefulSet</code> etc.) YAML to update the command to do nothing so one can <code>kubectl exec</code> into the pod<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-YAML data-lang=YAML><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
<span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
<span style=color:#f92672>metadata</span>:
  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>unstable-pod</span>
<span style=color:#f92672>spec</span>:
  <span style=color:#f92672>containers</span>:
  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>unstable-pod</span>
    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>foobar</span>
    <span style=color:#f92672>command</span>:
    - <span style=color:#ae81ff>sh</span>
    - -<span style=color:#ae81ff>c</span>
    - <span style=color:#e6db74>&#34;tail -f /dev/null&#34;</span>
</code></pre></div><p>Ensure <code>liveness</code> and <code>readiness</code> probes are commented out if it depends on a runtime condition.<h2 id=utilising-podmanagementpolicyhttpskubernetesiodocstutorialsstateful-applicationbasic-stateful-setpod-management-policy>Utilising <a href=https://kubernetes.io/docs/tutorials/stateful-application/basic-stateful-set/#pod-management-policy>podmanagementpolicy</a> <a href=#utilising-podmanagementpolicyhttpskubernetesiodocstutorialsstateful-applicationbasic-stateful-setpod-management-policy class="hash g">#</a></h2><p>Mostly used for <code>StatefulSets</code>. Setting <code>podManagementPolicy: "Parallel"</code> means the ordered pods will run and be terminated in parallel. Useful for when one doesn&rsquo;t care about pods starting serially, in order. Keep in mind, if a broken deployment is scaled with <code>n</code> pods, there will be an <code>n</code> amount of <code>CrashLoopBackOffs</code> in parallel.<h2 id=defaulting-to-retain-pvcs>Defaulting to Retain <code>PVCs</code> <a href=#defaulting-to-retain-pvcs class="hash g">#</a></h2><p>For example, creating a <code>StorageClass</code> (e.g., if GCP is the provider)<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>storage.k8s.io/v1</span>
<span style=color:#f92672>kind</span>: <span style=color:#ae81ff>StorageClass</span>
<span style=color:#f92672>metadata</span>:
  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>standard-pd-retain</span>
<span style=color:#f92672>provisioner</span>: <span style=color:#ae81ff>kubernetes.io/gce-pd</span>
<span style=color:#f92672>reclaimPolicy</span>: <span style=color:#ae81ff>Retain</span>
<span style=color:#f92672>allowVolumeExpansion</span>: <span style=color:#66d9ef>true</span>
<span style=color:#f92672>volumeBindingMode</span>: <span style=color:#ae81ff>WaitForFirstConsumer</span>
<span style=color:#f92672>parameters</span>:
  <span style=color:#f92672>type</span>: <span style=color:#ae81ff>pd-standard</span>
</code></pre></div><p>Where <code>reclaimPolicy: Retain</code> ensures if <code>PVs</code> are deleted, on the storage backed side (EBS, GCP Disks etc.) are preserved. The general idea is not to let Kubernetes actually delete any data, the <code>PV</code> will disappear but the volume will still persist outside of Kubernetes. This is useful when one accidentally deletes a <code>PV</code>, since it can be reattached to a new <code>PVC</code> for recovery (I’ve had to do this unfortunately).<h2 id=debugging-methods>Debugging Methods <a href=#debugging-methods class="hash g">#</a></h2><p>When something goes awry, and sometimes there isn&rsquo;t sophisticated monitoring already set up because there isn&rsquo;t enough time to build it yet—so one will probably need to get familiar with checking the right places, especially if an issue is urgent.<p>For example if something is broken and it’s not immediately obvious if it’s an application or a cluster-wide issue, a good order to deep-dive into things would be:<ul><li>Go by the first hunch and follow that (as one is naturally inclined to do). After a while one will learn the general pitfalls, or have built intuition.<li>Start by running <code>kubectl describe</code> on the pods that have issues and check the <code>events</code>.<li>Run <code>kubectl get events</code> in the namespace. Then <code>kubectl get events --sort-by=.metadata.creationTimestamp</code> and inspect.<li>Check <code>kubectl get pods -o wide</code> to see which node the pod is running on. Then <code>kubectl describe nodes</code> to see if there are issues with the particular node (or any others).<li>If it’s an issue with <code>PVCs</code>, check the persistent volumes since they sometimes get lost, via <code>kubectl get pv</code> or <code>kubectl describe pv</code>. If <code>PVs</code> are stuck as <code>Terminating</code>, edit the <code>PV</code> and delete the <code>Finalizers</code>.<li>If it’s a performance issue, use <code>watch -n5 kubectl top nodes</code> (or <code>kubectl top pods</code>) and inspect.<li>If it’s a scaling issue check <code>autoscaler kubectl -n kube-system logs -f deployment.apps/cluster-autoscaler</code>.<li>If it’s a networking issue check the Kubernetes DNS. In certain infra configurations <code>kube-dns</code> pods can be scheduled on only one node (sometimes a preemptible or spot node), guaranteeing downtime.<li>Check the VMs on the cloud provider if it&rsquo;s a compute issues, or the disk if it’s a storage issue. Sometimes it&rsquo;s preemptible/spot nodes going down (or the general provider itself)
Usually the problem will emerge. Normally one doesn&rsquo;t often need to directly connect to the VM.</ul><h2 id=statefulsets-are-more-trouble-than-theyre-worth><code>StatefulSets</code> are more trouble than they&rsquo;re worth <a href=#statefulsets-are-more-trouble-than-theyre-worth class="hash g">#</a></h2><p><code>StatefulSets</code> have their place, but in my opinion they’re not ideal when one really wants to principally keep state. Useful for general compute pods where it’s good to keep state between pod restarts and the like. But in situations where on is running a properly stateful service like <code>HDFS</code> or <code>ES</code>, a <code>Deployment</code> + <code>PVC</code> is almost always better. Here are some comparisons, say for a <code>HDFS</code> (namenode) pod with <code>n</code> datanodes:<ul><li>If one wants to remove ; number 4 of n in a <code>StatefulSet</code>, one has to scale them down since they’re ordered<li>If one wants to migrate the <code>PVs</code> to a different cluster, it&rsquo;s non-trivial since <code>volumeClaimTemplates</code> will create new <code>PVCs</code> + <code>PVs</code><li>If one accidentally delete the <code>StatefulSet</code>, the <code>volumeClaimTemplates</code> is removed, and non-trivial to reattach <code>PVs</code> (if they were set to <code>Retain</code>).<li>One can&rsquo;t have datanodes in a <code>StatefulSet</code> that have different <code>PVC</code> sizes, requests, env vars, or anything useful. They stay identical.</ul><h2 id=using-kubectl-diff-and-validate---dry-run>Using <code>kubectl diff</code> and <code>validate --dry-run</code> <a href=#using-kubectl-diff-and-validate---dry-run class="hash g">#</a></h2><p>Both useful for CI, but generally a good idea to check the <code>diff</code> of a resource that&rsquo;s about to updated.<h2 id=switch-namespaces-and-clusters-faster>Switch Namespaces and Clusters Faster <a href=#switch-namespaces-and-clusters-faster class="hash g">#</a></h2><p>Tools like <a href=https://github.com/ahmetb/kubectx>kubectx + kubens</a> are useful to switch between different clusters and namespaces faster. Renaming both binaries to <code>kcontext</code> and <code>knamespace</code> is another neat trick to make <code>kubectl</code> autocomplete.<h2 id=keeping-it-simple>Keeping it Simple <a href=#keeping-it-simple class="hash g">#</a></h2><p>Personally, I prefer <code>kustomize</code> + <code>envsubst</code> + <code>python</code> to template via <code>overlays</code>. I’m not into templating YAML (kustomize is advertised as &ldquo;template-free&rdquo; templating, but it&rsquo;s still somewhat <code>YAML HELL</code> like many things).<p>Personally I avoid using helm (messy configs, more moving parts, black box, the &ldquo;package management&rdquo; isn&rsquo;t a feature for me for infra code), or try not to i.e., generate <code>YAMLs</code> from a chart and use them. I try not use use too many Kubernetes operators or <code>CRDs</code>, generally keeping things stock and primitive. Of course complexity is always difficult to manage, so compromises are made. Programatically generating Kubernetes manifests is a good engineering idea, but probably overkill for many teams.</div></main>